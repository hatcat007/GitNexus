---
phase: 02-resilience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - gitnexus-mcp/src/mcp/resilience.ts
autonomous: true
must_haves:
  truths:
    - "Timeout wrapper enforces configurable limits per tool type"
    - "Circuit breaker factory creates breaker with 5-failure threshold and 30s cooldown"
    - "Backoff calculator produces exponential delays with jitter capped at 60s"
  artifacts:
    - path: "gitnexus-mcp/src/mcp/resilience.ts"
      provides: "Resilience utilities (timeout, circuit breaker, backoff)"
      min_lines: 80
      exports: ["withToolTimeout", "createCircuitBreaker", "calculateBackoff", "QUICK_TOOLS", "HEAVY_TOOLS"]
  key_links:
    - from: "resilience.ts"
      to: "process.env"
      via: "GITNEXUS_TIMEOUT_QUICK, GITNEXUS_TIMEOUT_HEAVY env vars"
      pattern: "process\\.env\\.GITNEXUS_TIMEOUT"
---

<objective>
Create the core resilience module with timeout wrapper, circuit breaker factory, and exponential backoff calculator.

Purpose: Provide reusable resilience utilities that protect the MCP server from hanging (timeouts), cascading failures (circuit breaker), and connection storms (backoff).
Output: `gitnexus-mcp/src/mcp/resilience.ts` with exported utilities
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-resilience/02-CONTEXT.md
@.planning/phases/02-resilience/02-RESEARCH.md

# Existing patterns to follow
@gitnexus-mcp/src/mcp/errors.ts
@gitnexus-mcp/src/mcp/logger.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create resilience.ts with timeout wrapper</name>
  <files>gitnexus-mcp/src/mcp/resilience.ts</files>
  <action>
Create `gitnexus-mcp/src/mcp/resilience.ts` with:

1. **Tool categorization constants:**
```typescript
export const QUICK_TOOLS = ['search', 'grep', 'read', 'context', 'overview', 'highlight'];
export const HEAVY_TOOLS = ['cypher', 'impact', 'explore'];
```

2. **Timeout configuration function:**
```typescript
export function getTimeout(toolName: string): number {
  const quick = parseInt(process.env.GITNEXUS_TIMEOUT_QUICK || '60000', 10);
  const heavy = parseInt(process.env.GITNEXUS_TIMEOUT_HEAVY || '120000', 10);
  
  if (QUICK_TOOLS.includes(toolName)) return quick;
  if (HEAVY_TOOLS.includes(toolName)) return heavy;
  return quick; // Default to quick
}
```

3. **Timeout wrapper using AbortController:**
```typescript
export async function withToolTimeout<T>(
  toolName: string,
  fn: (signal: AbortSignal) => Promise<T>
): Promise<T> {
  const timeoutMs = getTimeout(toolName);
  const controller = new AbortController();
  const timeoutId = setTimeout(() => {
    controller.abort(new Error(`Tool ${toolName} timed out after ${timeoutMs}ms`));
  }, timeoutMs);

  try {
    return await fn(controller.signal);
  } finally {
    clearTimeout(timeoutId);
  }
}
```

Use native Node.js AbortController (available since v15, project uses v18+). Do NOT use `AbortSignal.timeout()` as it has different error handling behavior.
  </action>
  <verify>node -e "const r = require('./gitnexus-mcp/dist/mcp/resilience.js'); console.log('QUICK_TOOLS:', r.QUICK_TOOLS); console.log('getTimeout:', typeof r.getTimeout); console.log('withToolTimeout:', typeof r.withToolTimeout);" (after npm run build)</verify>
  <done>resilience.ts exists with QUICK_TOOLS, HEAVY_TOOLS, getTimeout(), and withToolTimeout() exported</done>
</task>

<task type="auto">
  <name>Task 2: Add circuit breaker factory</name>
  <files>gitnexus-mcp/src/mcp/resilience.ts</files>
  <action>
Add circuit breaker factory to resilience.ts:

1. **Import opossum at the top:**
```typescript
import CircuitBreaker from 'opossum';
```

2. **Circuit breaker config interface:**
```typescript
export interface CircuitBreakerConfig {
  failureThreshold: number;  // 5 consecutive failures
  resetTimeoutMs: number;    // 30 seconds
}
```

3. **Circuit breaker factory function:**
```typescript
export function createCircuitBreaker(
  callTool: (method: string, params: any) => Promise<any>,
  config: CircuitBreakerConfig = { failureThreshold: 5, resetTimeoutMs: 30000 }
): CircuitBreaker {
  const breaker = new CircuitBreaker(callTool, {
    timeout: false,  // We handle timeout separately with AbortController
    errorThresholdPercentage: -1,  // Disable percentage-based
    resetTimeout: config.resetTimeoutMs,
    rollingCountBuckets: 1,
    volumeThreshold: 0,
  });

  // Track consecutive failures for threshold (opossum doesn't do this natively)
  let consecutiveFailures = 0;
  
  breaker.on('failure', () => {
    consecutiveFailures++;
    if (consecutiveFailures >= config.failureThreshold) {
      if (!breaker.opened) {
        breaker.open();
      }
    }
  });
  
  // Reset on success (immediate close - per CONTEXT.md decision)
  breaker.on('success', () => {
    consecutiveFailures = 0;
    if (breaker.halfOpen) {
      breaker.close();  // Close immediately on successful test
    }
  });

  return breaker;
}
```

Do NOT create the breaker instance here - just export the factory. The server.ts will create the instance.
  </action>
  <verify>node -e "const r = require('./gitnexus-mcp/dist/mcp/resilience.js'); console.log('createCircuitBreaker:', typeof r.createCircuitBreaker);" (after npm run build)</verify>
  <done>createCircuitBreaker() exported, accepts callTool function and config, returns opossum CircuitBreaker with consecutive failure tracking</done>
</task>

<task type="auto">
  <name>Task 3: Add exponential backoff calculator</name>
  <files>gitnexus-mcp/src/mcp/resilience.ts</files>
  <action>
Add backoff calculator to resilience.ts:

```typescript
export interface BackoffConfig {
  baseDelayMs: number;    // 500ms initial
  maxDelayMs: number;     // 60s cap
}

/**
 * Calculate exponential backoff delay with Full Jitter.
 * Based on AWS research: https://aws.amazon.com/blogs/architecture/exponential-backoff-and-jitter/
 * Full Jitter: sleep = random(0, min(cap, base * 2^attempt))
 */
export function calculateBackoff(
  attempt: number,
  config: BackoffConfig = { baseDelayMs: 500, maxDelayMs: 60000 }
): number {
  // Exponential: base * 2^attempt, capped at max
  const exponential = Math.min(
    config.maxDelayMs,
    config.baseDelayMs * Math.pow(2, attempt)
  );
  
  // Full jitter: random value from 0 to exponential
  // AWS research shows Full Jitter reduces contention by 50%+
  return Math.floor(Math.random() * exponential);
}
```

This is a pure function - no state management. The WebSocket server will manage attempt count.
  </action>
  <verify>node -e "const r = require('./gitnexus-mcp/dist/mcp/resilience.js'); console.log('calculateBackoff(0):', r.calculateBackoff(0)); console.log('calculateBackoff(5):', r.calculateBackoff(5));" (after npm run build)</verify>
  <done>calculateBackoff() exported, returns delay in milliseconds with Full Jitter algorithm, capped at 60s</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run build` succeeds without errors
2. resilience.ts exports: QUICK_TOOLS, HEAVY_TOOLS, getTimeout, withToolTimeout, createCircuitBreaker, calculateBackoff
3. No hardcoded timeout values (all use env vars with defaults)
4. opossum imported correctly (check it's in package.json)
</verification>

<success_criteria>
- resilience.ts exists with ~100+ lines
- All three utilities (timeout, circuit breaker factory, backoff) exported
- Environment variable fallbacks implemented
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-resilience/02-01-SUMMARY.md`
</output>
